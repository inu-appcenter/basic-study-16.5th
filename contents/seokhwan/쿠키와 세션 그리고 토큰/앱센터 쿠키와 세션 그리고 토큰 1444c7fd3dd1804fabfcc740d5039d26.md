# 앱센터 쿠키와 세션 그리고 토큰

추가 일시: 2024년 11월 21일 오전 12:53
강의: 앱센터_Basic_study

# 쿠키와 세션 그리고 토큰

## 쿠키와 세션은 무엇인가?

---

### ✅ HTTP 프로토콜에서 쿠키와 세션을 사용하게 된 이유가 무엇일까요?

HTTP 프로토콜은 Request와 Response 구조로 이루어져 있다.

사용자가 웹 브라우저를 통해 어떤 페이지를 요청하면, 서버는 이에 대한 응답을 보내게 된다.

이 과정에서 데이터의 형식, 보안, 세션 관리 등 다양한 문제를 해결해야 한다.

HTTP 프로토콜은 상태를 유지하지 않는 Stateless 특성을 가지고 있다.

서버가 클라이언트의 이전 상태를 기억하지 않는다는 것.

때문에 웹 개발에서 이러한 한계를 극복하기 위해 Cookie와 Session 같은 기술을 사용한다.

Cookie와 Session을 통해 사용자의 상태 정보를 서버나 클라이언트 측에서 유지할 수 있다.

이를 통해 로그인 상태 유지, 사용자의 선호 설정 등 다양한 기능을 구현 할 수 있다.

### 🍪 쿠키는 무엇일까요?

![image.png](image.png)

- Cookie는 웹 서버가 사용자의 웹 브라우저에 저장하는 작은 데이터 조각.

이를 통해 서버는 사용자의 이전 방문 정보, 로그인 상태 등을 기억할 수 있다.

쿠키는 주로 사용자 인증, 세션 관리, 사용자의 선호 설정 저장 등에 사용된다.

- key-value 형식의 문자열 형태로 저장

```json
{   
	"Set-Cookie" : "id=user123",
	"Set-Cookie" : "pw=pw1234@"
}
```

- Cookie의 한계

쿠키의 가장 큰 장점은 간단한 구현과 빠른 처리 속도이다.

다만, 쿠키는 클라이언트 측에 저장되기 때문에 보안에 취약하다는 단점이 있다.

쿠키 정보가 암호화되지 않은 상태로 전송되면 정보가 노출될 수 있다.

쿠키는 브라우저마다 별도로 저장되므로, 같은 사용자가 다른 브라우저를 사용할 경우 정보가 공유되지 않는 문제가 있다.

이러한 쿠키의 한계를 극복하기 위해 세션과 토큰 기반의 인증 방식이 등장했다.

쿠키의 유형으로는 세션 쿠키, 영구 쿠키, 인증 쿠키, 추적 쿠키, 좀비 쿠키 등이 있다. 

### ✅ 세션이란 무엇일까요?

![image.png](image%201.png)

- Session은 일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로  보고, 그 상태를 유지시키는 기술.

일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저 종료 시점.

즉, 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술을 세션이라 한다.

- 세션의 특징

웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.

**웹 서버에 저장되는 쿠키(session cookie)이다.**

브라우저를 닫거나, 서버에서 세션을 삭제했을 때 삭제가 되기 때문에 쿠키보다 보안 우수.

저장 데이터의 제한이 없다. (쿠키는 도메인당 20개의 쿠키, 하나의 쿠키는 최대 4KB) 

### 📌 쿠키와 세션의 관계는 어떻게 될까요? 전송 흐름에 맞춰 생각해보세요!

- 쿠키의 전송흐름

<aside>
💡

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키 생성
3. HTTP 헤더에 쿠키를 포함하여 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 잇을 때 쿠키를 업데이트하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답
</aside>

- 세션의 전송흐름

<aside>
💡

1. 클라이언트가 서버에 접속 시 세션 ID를 발급 받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
4. 서버는 세션 ID를 전달 받아 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와서 사용
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답
</aside>

### ⁉️ 그렇다면, 쿠키와 세션의 차이점은 어떤 게 존재할까요?

|  | Cookie | Session |
| --- | --- | --- |
| 저장 위치 | Clinet | Server |
| 저장 형식 | Text | Session ID만 저장 |
| 만료 시점 | 쿠키 저장 시 설정 | 브라우저 종료, Server에서 Session 삭제 |
| 리소스 | Client resource | Server resource |
| 용량 제한 | 도메인 당 20개, 쿠키 하나당 4KB | 제한 없음 |
| 속도 | 정보가 클라이언트에 있어 빠름 | 정보가 서버에 있어 느림 |

- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷하다 → 세션도 쿠키를 사용하기 때문
- 가장 큰 차이점은 사용자 정보가 저장되는 위치.
- 쿠키는 서버의 자원을 사용하지 않고, 세션은 서버의 자원을 사용함.
- 보안적 측면에서 세션이 더 우수하며, 요청 속도는 쿠키가 더 빠르다.
- 쿠키는 브라우저가 종료되도 만료기간에 따라 유지 될 수 있다.
- 세션은 브라우저가 종료되면 삭제

## 세션 기반 인증과 토큰 기반 인증

---

### ⏳ 세션 기반 인증의 흐름 방식

![image.png](image%202.png)

- 세션 기반 인증은 상용자의 상태를 **서버**에서 유지하고 관리한다.
- 사용자가 로그인하면 서버는 사용자를 식별하는 세션 ID를 생성하고, 이 세션 ID를 클라이언트에게 부여한다.
- 세션 ID는 tyically 쿠키를 통해 클라이언트에 저장되며, 이후 사용자의 모든 요청은 서버로 전송된다.
- 서버는 클라이언트가 제공한 세션 ID를 확인하여 해당 세션에 대한 상태를 확인하고 사용자를 인증하며 권한을 부여한다.
- 클라이언트는 세션 정보에 직접 접근할 수 없다.

### ⏳ 토큰 기반 인증의 흐름 방식

![image.png](image%203.png)

- 토큰 기반 인증은 사용자의 상태를 **클라이언트** 측에서 관리한다.
- 사용자가 로그인하면 서버는 클라이언트에게 Access Token을 발급한다.
- 이 토큰은 사용자를 인증하고 권한을 부여하는 데 사용된다, 클라이언트는 모든 요청에서 이 액세스 토큰을 포함하여 서버로 보낸다.
- 서버는 액세스 토큰을 검증하고, 해당 토큰이 유효하면 사용자를 인증하고 요청을 처리한다.
- 토큰은 일반적으로 JWT(JSON Web Token) 형식으로 사용되며, 클라이언트는 토큰을 디코딩 하여 사용자 정보 및 권한을 확인할 수 있다.

☑️**JWT 구조**

![image.png](image%204.png)

### 🔍 각 인증 방식에서 헤더 작성 방식

> **세션 기반 인증**
> 

- 로그인 요청

```json
POST /login HTTP/1.1
Host: example.com
Content-Type: application/json

{
    "username": "user1",
    "password": "password123"
}
```

- 응답 (세션  ID를 생성하고 쿠키에 담아 전달)

```json
HTTP/1.1 200 OK
Set-Cookie: session_id=abcd1234; Path=/; HttpOnly; Secure
```

- 인증 후 요청

```json
GET /protected/resource HTTP/1.1
Host: example.com
Cookie: session_id=abcd1234
```

---

> **토큰 기반 인증**
> 

- 로그인 요청

```json
POST /login HTTP/1.1
Host: example.com
Content-Type: application/json

{
    "username": "user1",
    "password": "password123"
}
```

- 응답 (토큰을 생성하고 본문 또는 헤더에 담아 전달)

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

- 인증 후 요청

```json
GET /protected/resource HTTP/1.1
Host: example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 🔰 클라이언트에서 토큰은 어떻게 관리가 될까요?

1. **localStorage**

<aside>
📌

- 브라우저에 저장되며, 브라우저를 닫아도 데이터가 유지
- 데이터가 브라우저 세션을 넘어 유지되므로 사용자가 새로 로그인할 필요가 없다.
- 접근 및 관리가 쉽고 사용자가 제어 가능
</aside>

1. **sessionStorage**

<aside>
📌

- 브라우저 세션 동안만 데이터가 유지되며, 브라우저 탭이나 창을 닫으면 데이터가 삭제
- 탭별로 독립적인 저장소를 제공하므로, 한 탭에서 로그아웃해도 다른 탭에 영향을 주지 않음
- 브라우저를 닫으면 토큰이 삭제됨
</aside>

1. **cookie**

<aside>
📌

- 토큰을 클라이언트 쿠키에 저장하며, 요청시 자동으로 서버로 전송
- 브라우저가 요청할 때마다 자동으로 서버에 쿠키를 첨부하므로 추가 작업이 필요 없다.
</aside>

## 실무에서는 어떤 인증 방식을 사용할까?

---

**(개인적인 생각)**

<aside>
⚠️

세션 기반 인증의 경우 세션 데이터를 서버에서 관리하기 때문에 보안이 중요한 분야에서 활용될 여지가 많다고 보여진다.

토큰 기반 인증의 경우 서버가 인증상태를 유지하지 않아도 되기 때문에 서버 부하를 줄이는데 유용하게 사용 될 것이다.

</aside>

## + 추가로 공부해보면 좋을 개념

---

### 👌 캐시

- 캐시(Cache)의 의미
    - 캐시는 메모리, 디스크, 브라우저, 서버와 같은 저장소에 저장되는 임시 데이터
    - 자주 사용되는 데이터를 케시에 저장하여 이후 요청에 빠르게 응답

- 캐시는 왜 사용할까요? (캐시의 장점)
    - 데이터를 미리 저장해두기 때문에 네트워크 요청을 줄여 응답속도를 개선
    - 동일한 데이터를 여러 번 처리하거나 전송하지 않으므로 서버 부하와 네트워크 트래픽을 감소

- 추가) 캐시 교체 알고리즘의 종류
    - **LRU**
    
    <aside>
    👉
    
    **Least Recently Used Algorithm**
    
    마지막 참조시점이 가장 오래된 캐시를 교체하는 알고리즘
    
    </aside>
    
    - **FIFO**
    
    <aside>
    👉
    
    **First in First Out Algorithm**
    
    가장 먼저 들어간 캐시를 교체 하는 알고리즘
    
    </aside>
    
    - **LFU**
    
    <aside>
    👉
    
    **Least Frequently Used Algorithm**
    
    가장 적은 횟수를 참조하는 캐시를 교체하는 알고리즘
    
    </aside>
    

- 추가) 로컬에 캐싱되는 경우는 개발자 도구에서 어떻게 표시되는 지 확인해보세요!