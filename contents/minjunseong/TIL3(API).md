# Appcenter Basic Course Study 3 : API

### Computer Network Basics
학부 3학년 전공과정에서 데이터통신, 컴퓨터 네트워크라는 과목을 배우게 될 것이다.
아니 API 하는데 이걸 왜 알아야하지? 하는 생각이 들 수 있지만,
컴퓨터네트워크라는 과목 자체가 CS 4대 과목(자료구조, 컴퓨터네트워크, 컴퓨터아키텍쳐, 운영체제)중 하나이기 때문이기도 하고, 실제로 이따 기술하겠지만, HTTP라는 통신이 OSI 7계층 중 7번째 Layer에서 이루어진다.

우선 우리가 접근하는 웹이나, 혹은 사내 인트라넷이나, 혹은 학교 포털이나 등등.. 당연히 인터넷 통신이 연결되어야 가능하다.
이 인터넷이라는 근간을 좀 더 자세히 보면, 네트워크가 다양한 계층에서 얽히고 얽혀 패킷이라는 단위로 데이터가 오고가는 것인데, 이를 정리한 것이 바로 OSI 7계층이다. 

L1 : 물리(랜선이 꼽혀있나?) / L2 : 데이터링크(흐름관리) / L3 : 네트워크(IP주소설정, 데이터를 어디다 보낼지? 라우팅) / L4 : 전송계층(TCP와 UDP 프로토콜을 활용하여 End to End로 보내는 것.) / L5 : 세션 / L6 : 표현 / L7 : 응용계층
이 많은 계층 중 가장 꼭대기 계층인 7번째 계층에서 HTTP 통신이 일어난다.

참고로 이 HTTP는 TCP/IP 프로토콜을 기반으로 만들어진 통신 프로토콜이다. TCP는 순서가 보장되고, 패킷의 실패 없는 전송을 위해 다시 전송하는 등의 방식을 이용하는 특징이 있다.
또, TCP는 보다 완벽한 전송을 위해 3way Handshaking이라는 방식을 이용한다.
SYN패킷을 통한 서버 연결 요청 -> 서버의 ACK라는 긍정 응답 -> 클라이언트의 ACK 회신으로 정상적으로 서버-클라이언트가 연결되며 데이터가 오고가는 것이다. 그래서 HTTP 모델이 서버-클라이언트 모델로 유명한 이유가 바로 여기서 나오기도 한다.

### 그래서 HTTP Protocol은 뭐지?
먼저 프로토콜이란, 간단하게 말해서 통신 규약이라고 부른다. 그럼 HTTP는 어떤 통신 규약을 사용하는가? 에 대해 살펴보자면, 위에서도 언급했듯 서버와 클라이언트를 연결하기 위한 매개체라고 볼 수 있는데, 서버와 클라이언트 사이에서 요청과 응답을 처리하는 프로토콜이 바로 HTTP이다.

### 그럼 그 응답과 요청은 어떤 방식으로 처리되는건데요?
밑에서 자세히 기술하겠지만, 잠시 언급해보자면, GET, POST등과 같은 Method를 서버에 요청하면, 이에 대한 응답으로 Status Code를 전송한다. 정상적인 요청이면 긍정적인 Status Code를 전송하고, 비정상적인 접근이거나 잘못된 요청을 할 시엔 부정적인 Status Code를 전송한다.

### HTTP 말고 HTTPS는 뭐죠? 요즘 사이트들은 다 이거로 시작하던데..
HTTPS에서의 S는 Secure의 약자로, 프로토콜의 첫 연결시 인증서라는 비대칭키를 이용하여 보안 연결을 하여 웹사이트에 접근할 수 있는 방식이다. HTTPS의 통신 방식을 살짝만 설명해보자면

- 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
- 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
- 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
- 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함
- 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
- 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함

놀라운 사실이지만 HTTP도 사실 암호화 통신을 지향한다. 그러나, CA를 통한 인증서 발급의 유무가 HTTPS와의 차이를 보여준다고 볼 수 있다.

### HTTP 주요 요소와 작동원리
### URI? URL?
URI는 웹 상에서 존재하는 모든 리소스를 식별하거나 가리킬 때 쓰인다. I의 약어인 Identifier 그대로이다. URL은 URI의 하위개념으로, 실제 있는 리소스를 주소로 표현할 때 쓴다고 한다.
-> 개인적인 의견으로, 솔직하게 말해서 둘의 차이가 매우 애매하다고 생각이 된다. 굳이 구분하는 이유가 무엇일까?

### BaseURL
자세하게 정의를 내리는 내용은 아직 얻진 못했지만, 경로의 명확성을 위해 사용하는 것으로 확인된다. 또한, baseurl을 사용하는 이유는 테스트하는 내부 웹서버의 url과 배포 서버의 url을 같게하기 위해서라고한다. 이 외에도, 경로의 복잡성을 줄여준다.

### Endpoint
사실 API의 개념을 미리 숙지하고 보면 좋겠지만, 네트워크의 요청을 구별해주는 것이 바로 엔드포인트라고 한다. HTTP의 메소드에 따라 Endpoint의 행위가 달라진다. ex : 해당 URI에서 POST 요청을 보내면, 엔드포인트는 새로운 도서 정보를 생성한다.


### HTTP Message
HTTP는 앞에 언급했듯 서버와 클라이언트 사이에서 요청과 응답을 주고받는 프로토콜이다. HTTP Message 또한 응답과 요청의 메시지로 구분이 되며, 이는 각각 헤더와 바디를 가지고 있다.
와이어샤크 실습을 통해서 HTTP Message가 어떻게 주고받는지 알 수 있는데, 요청의 메시지와 응답의 메시지가 사뭇 구조가 다르다.

HTTP 메시지를 천천히 살펴보자.
우선 Client의 입장인 요청 HTTP Message를 보자.
우선 Start-Line에서는 Method, 요청 URI, HTTP 버전이 포함되어있다.
그 다음엔 클라이언트 정보, User-Agent와 같은 메타데이터를 내포한 내용이 요청 헤더에 들어가있다.
그리고 바디에는 클라이언트가 서버로 보낼 데이터들이 있을텐데, 주로 로그인할때의 ID,PW가 있거나 / 인스타그램에 뭐 게시글을 올리고 싶을때 적는 해시태그, 글 내용, 사진 등이 있겠다.

반대로 Server 입장인 응답 HTTP Message를 보면,
Start-Line에 HTTP 프로토콜 정보와 Status Code를 담고 있고, 헤더에는 서버 정보, 컨텍스트의 길이나 유형 등을 담고 있겠다. 바디에는 Client가 아까 로그인을 하는 요청 데이터를 보냈다면, Server 입장에서 로그인된 사용자 정보 혹은 Access Token 등을 제공해서 웹서비스를 이용하게끔 할 것이다. 또 예시로 들었던 인스타에 올리려고 쓴 요청 HTTP Message를 쓴 내용이 그대로 잘 올라갔다는걸 보여주며 반환할 것이다.

### 그럼 Status Code, Method 이건 뭐지?
#### METHOD
- GET : 단순히 조회할 때 쓰인다. GET은 정적 조회 방식과 동적 조회 방식이 있는데, 정적 조회 방식은 순수히 리소스 값을 URI로 접근해서 가져오는 것이고, 동적 파라미터는 & 기호의 쿼리 파라미터를 이용하여 원하는 값을 필터를 통해 가져오는 방식이 있다. 추가적인 내용이지만, 혹시 HTML을 조금이라도 건드려본 사람이 있다면, HTML Form에 대해서는 모두 알 것이다. 아이디 넣고 비번 넣고 하는... 이 HTML Form은 GET과 POST만 지원된다고 한다. GET은 CRUD에서 R, Read에 해당할 것 같다.
- POST : GET이 조회에 해당하는 거였다면, POST는 Create에 해당된다. 보통 클라이언트가 body에 원하는 내용을 담아서 Server에 전송하여, 이를 반영하도록 한다. 예를 들어 이름 : Minjun Seong, 직업 : 백수 라는 내용의 유저 데이터로 가입을 원하면, 해당 클라이언트는 위와 같은 내용이 json형식의 파일 혹은 form의 파라미터 값을 통해 서버에 전송되고, 이를 요청받은 서버는 해당 데이터를 생성한 것을 보여주며 신규 유저가 정상적으로 가입되었다는 응답을 보내준다.
- PUT/PATCH : 일부 정보를 수정할 때엔 PATCH를 이용하며, 전체 정보를 수정할 땐 PUT를 이용한다. PATCH는 지원안하는 서버가 종종 있다. 그러나 PUT을 이용하게 된다면 해당 회원 정보의 일부만을 수정하고 싶을 때, 나머지 리소스 정보도 같이 넣어서 보내주어야한다. 예를들어 이름, 나이 정보 중 나이만 수정하고 싶다고 나이만 수정한 데이터를 보내게 되면, 이름 정보가 날라가버리는 현상이 생겨버린다. 어떻게 보면 PUT은 동시에 CREATE 기능을 하기도 한다. CRUD중에서 Update에 해당하는 부분이다.
- DELETE : DELETE는 말 그대로 해당 리소스를 제거하는데에 사용된다. CRUD중에서 D의 역할을 맡는다.


#### Status Code
주로 2xx는 성공 응답, 3xx는 redirection이며 GET을 통해 조회할 때 반환하는 코드이기도 합니다, 4xx는 클라이언트 오류, 5xx는 서버 오류를 나타냅니다.
- 200 : 대부분의 메서드에서 OK사인을 받을 때 받는 STATUS CODE입니다.
- 201 : 생성이 제대로 됐을 때 반환하는 STATUS CODE로, 주로 POST, PUT METHOD에서 사용됩니다.
- 204 : DELETE 메서드가 정상적으로 작동되었을 때 반환하는 성공 코드입니다. 204는 보통 반환할 내용이 더 이상 없음을 나타냅니다.
- 400 : 문법의 오류나, JSON 파일의 오류로 인해 발생하게 되는 클라이언트 오류입니다. 대부분의 메서드에서 일어날 수 있는 STATUS CODE입니다.
- 403 : 클라이언트가 리소스에 접근할 수 없음을 나타내며, 인증은 되었으나 권한이 부족한 경우에 뜨는 Forbidden Status Code입니다.
- 404 : 존재하지 않는 리소스에 접근했을 때 나타나는 Status Code로, 찾을 수 없는 페이지임을 나타내는 오류 Status Code입니다. 실제로 404 not found라는 멘트를 서칭하다보면 어렴풋이 보게 되기도 합니다.
- 500 : 서버가 클라이언트의 요청을 처리하는 도중, 예기치 않은 오류가 발생했을 때 나타나는 Status Code입니다.

    
### API란?

- Application Programming Interface의 약어로써, 프로그램들이 서로 상호작용하도록 하는 매개체라고 정의를 내릴 수 있다. 사실상 흔히들 말하는 웹에서의 API 뿐만 아니라, 운영체제 레벨에서도 이 개념이 적용되기도 한다. 대표적으로 c언어 코딩을 할 때, fopen과 같이 운영체제 위에 있는 파일이나 폴더들을 열기 위해서 해당 함수를 이용해본 경험이 있을 것이다. 이렇게 함수를 통해 간접적인 System Call로 운영체제의 기능을 쓸 수 있도록 하는 것들이 운영체제에서의 API라고 볼 수 있다. 웹도 마찬가지다. 우리가 결제하거나 회원가입을 하거나 하는 일련의 동작들이 다 API를 통해 이루어지고 있는 것이다.

### REST API란?

REST의 뜻풀이부터 해보면, REpresentational State Transfer로 정의된다. 네트워크로 연결된 시스템 설계 방법에 대한 아이디어 모음이다. 하나의 방법론 같은거다. REST에 담겨있는 아이디어나 방법론들을 참고해보면, 단순함과 API와 API를 공급하는 서비스를 분리하는 데에 목표를 두고 있다. 분리를 왜하냐면은, 서버가 클라이언트의 상태를 저장하지 않도록 하는 것이다. 이슈가 발생하기 좋기에... 또, 외에도 REST는 주로 요청-응답 모델을 사용한다는 점에서 HTTP와 많이 닮아있음을 알 수 있다. 실제로 HTTP 프로토콜을 기반으로 한다. 하지만 HTTP 메소드를 마구잡이로 이용하는것과 REST한 설계는 차별점을 두어야한다.

REST의 핵심 아이디어는 자원을 어떻게 활용하느냐이다. URI로 인한 자원의 식별이 중요하며, API 안에서만 자원을 식별할 수 있도록 해야한다. 그리고 자원에 대한 작업으로 HTTP 메서드를 적극적으로 활용한다. 주로 GET, PUT/PATCH, DELETE, POST를 활용한다. 그리고 각 요청이 독립적으로 처리되도록, 서버에 클라이언트 내용이 저장되지 않도록 무상태라는 조건을 지켜야하며, JSON과 XML이라는 표현을 준수한다. 또한, 클라이언트측에선 서버로부터 받은 응답을 캐싱하여 반복된 요청을 줄이고 리소스 관리를 효율적으로 해야한다.

- 장점 : HTTP 기반으로 인프라가 구축됨 -> 설계에 용이 / 서버와 클라이언트 역할을 명확하게 분리해준다. / HTTP 표준 프로토콜을 준수하는 서비스에는 모두 사용이 가능하다
- 단점 : 딱히 표준이 존재하지 않는다 -> REST한 API인지 아닌지 판단이 어려울 수 있음(애매함) / 구형 브라우저는 아직 PUT, DELETE를 지원하지 못한다. / 높은 트래픽 상황에서는 서버와 클라이언트의 분리가 오히려 단점으로 작용하여 성능 저하 이슈가 생긴다. 

### HTTP와 REST API의 관계성
우선 HTTP 프로토콜을 기반하는 것이 바로 REST API이다. HTTP의 주요 메서드를 활용하기 때문에 자원에 대한 다양한 작업이 수행 가능하다. 서로 상호 보완적이라는 특징이 있으며, HTTP 프로토콜의 특성을 통해 간결하고 직관적인 API 설계가 가능하다.

- REST API설계에서 HTTP 메서드 활용 예시
    위에 언급한 GET, PUT/PATCH, POST, DELETE 메서드에 대한 내용과 동일한데, 한번 예시로 보겠다.
    ```
    GET : DATA 조회 (/user + GET -> USER에 대한 데이터 조회)
    PUT : 사용자 정보 전체 수정 (/user/minjunseong + PUT -> minjunseong에 대한 사용자 정보 전체 수정)
    PATCH : 사용자 데이터 일부 수정 (/user/minjunseong + PATCH -> minjunseong에 대한 일부 내용 편집)
    POST : 유저 생성 (/user + POST -> 신규 유저 등록)
    DELETE : 유저 삭제 (/user/minjunseong + DELETE -> USER 삭제) 
    ```
- RESTful 하게 API 설계하는 방법
  - 모든 자원들을 URI로 표현하고, HTTP 메서드를 통해 CRUD 원칙을 지키는 것이 일반적인 설계 원칙이다
  - 일관된 구조를 사용해야하며, HTTP 상태 코드를 통해 User가 직관적인 이해를 할 수 있어야한다.
  - 엔드포인트 이름은 항상 복수형으로 해야한다. (지금 보면 엔드포인트가 URI의 끝지점 이라고 볼 수도 있겠다.)
  - 항상 SSL을 사용하여 보안을 강화해야한다.
  - 누구나 접근하기 쉬운 직관적인 API 문서화가 중요하다.
  - 응답 형태는 JSON만 활용해야한다.

### XML과 JSON 이란 ?

- XML의 기본 구조 및 태그 사용방식
XML : EXTensible Markup Language
Markup Language 특성 상 태그 활용을 주로 한다.
- XML의 특징과 장점
어느 데이터가 어느 요소인지 직관적인 파악은 가능하지만, 훌륭한 대체재인 JSON이 있고, 여는 태그와 닫는 태그로 이루어진 바람에 바이트 차지가 좀 있으며, 데이터가 길어지면 오히려 한눈에 보기 불편하다는 점도 있다. 파싱 성능도 JSON에 비해 뒤쳐진다.

- JSON의 기본 구조 및 표현 방식
JSON : Javascript Object Notation
자바스크립트의 객체 표기법을 준수한다. 특히 Data Parsing과 같은 작업을 할땐 JSON이 효율적이라고 들었다. 파싱이란 대규모 데이터에서 원하는 일부 데이터만 추출하는 방식을 의미한다.
- JSON의 특징과 장점
JSON은 괄호와 콜론의 형태를 유지하며, 주로 Key-Value 형태를 갖추고 있다. REST API에서 널리 쓰이고 있으며 거의 표준이다.
단점으론 UTF-8 인코딩만을 지원한다는 점이고, 보안에 취약하다는 단점이 있다.
- REST API 에서는 어떤걸 기준으로 사용할까요?
위에 언급한 장점으로 인해 주로 JSON을 활용한다. 쉽게 파싱할 수 있다는 장점으로 인해 XML보다 선호되고 있다.